local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/shlexware/Rayfield/main/source"))();
local Window = Rayfield:CreateWindow({Name="FF2 script",LoadingTitle="POOG FOOG YT",LoadingSubtitle="by Poog Foog",ConfigurationSaving={Enabled=true,FolderName=Poog,FileName="Poog hub"},Discord={Enabled=false,Invite="noinvitelink",RememberJoins=true},KeySystem=false,KeySettings={Title="Sirius Hub",Subtitle="Key System",Note="Join the discord (discord.gg/sirius)",FileName="SiriusKey",SaveKey=true,GrabKeyFromSite=false,Key="Hello"}});
local Main = Window:CreateTab("Main", 4483362458);
local MainSection = Main:CreateSection("Main");
local Visuals = Window:CreateTab("Visuals", 4483362458);
local VisualsSection = Visuals:CreateSection("Visuals");
local Player = Window:CreateTab("Player", 4483362458);
local PlayerSection = Player:CreateSection("Player");
local Anims = Window:CreateTab("Anims", 4483362458);
local AnimsSection = Anims:CreateSection("Anims");
local MainButton = Main:CreateButton({Name="Mags",Callback=function(MainSlider)
	local MainSlider = Main:CreateSlider({Name="Mags",Range={0,30},Increment=1,Suffix="Range",CurrentValue=30,Flag="Slider1",Callback=function(maxdistance)
		local lp = game:GetService("Players").LocalPlayer;
		local stepped = game:GetService("RunService").Stepped;
		local user = game:GetService("UserInputService");
		local gui = game:GetService("GuiService");
		local maxdistance = 30;
		local autoclickoffset = nil;
		local escmenu = false;
		autoclickoffset = autoclickoffset and (autoclickoffset + maxdistance);
		local infinite = math.huge;
		local workspace = workspace;
		local firetouchinterest = firetouchinterest;
		local FindFirstChild = game.FindFirstChild;
		local FindFirstChildOfClass = game.FindFirstChildOfClass;
		local task = task;
		local connect = stepped.Connect;
		local waitfor = stepped.Wait;
		local keypress = keypress;
		local keyrelease = keyrelease;
		local gettextbox = user.GetFocusedTextBox;
		local pairs = pairs;
		local catchparts = {"CatchRight","CatchLeft"};
		local function resolveShortest(ball, charac)
			local shortest, chosen = infinite, nil;
			for i, name in pairs(catchparts) do
				local part = FindFirstChild(charac, name);
				local dist = (part and (part.Position - ball.Position).Magnitude) or infinite;
				if (dist < shortest) then
					shortest = dist;
					chosen = part;
				end
			end
			return shortest, chosen;
		end
		local function WaitForChildOfClass(inst, child, maxtime)
			local timer = 0;
			maxtime = maxtime or infinite;
			local found = FindFirstChildOfClass(inst, child);
			while not found and (timer < maxtime) do
				timer = timer + task.wait();
				found = FindFirstChildOfClass(inst, child);
				if found then
					return found;
				end
			end
			return found;
		end
		connect(gui.MenuOpened, function()
			escmenu = true;
		end);
		connect(gui.MenuClosed, function()
			escmenu = false;
		end);
		connect(workspace.ChildAdded, function(ball)
			if ((ball.Name == "Football") and WaitForChildOfClass(ball, "TouchTransmitter", 3)) then
				local charac = lp.Character;
				while (ball.Parent == workspace) and charac do
					local dist, part = resolveShortest(ball, charac);
					if part then
						if (autoclickoffset and (dist <= autoclickoffset) and not (gettextbox(user) or escmenu)) then
							keypress(67);
							keyrelease(67);
						end
						if (dist <= maxdistance) then
							firetouchinterest(part, ball, 1);
							firetouchinterest(part, ball, 0);
						end
					end
					waitfor(stepped);
				end
			end
		end);
	end});
end});
local MainButton = Main:CreateButton({Name="Auto Hands",Callback=function()
	local MainSlider = Main:CreateSlider({Name="Distance of Auto hands",Range={0,20},Increment=0.1,Suffix="Distance",CurrentValue=20,Flag="Slider1",Callback=function(autoclickoffset)
		local lp = game:GetService("Players").LocalPlayer;
		local stepped = game:GetService("RunService").Stepped;
		local user = game:GetService("UserInputService");
		local gui = game:GetService("GuiService");
		local maxdistance = 30;
		local autoclickoffset = 20;
		local escmenu = false;
		autoclickoffset = autoclickoffset;
		local infinite = math.huge;
		local workspace = workspace;
		local firetouchinterest = firetouchinterest;
		local FindFirstChild = game.FindFirstChild;
		local FindFirstChildOfClass = game.FindFirstChildOfClass;
		local task = task;
		local connect = stepped.Connect;
		local waitfor = stepped.Wait;
		local keypress = keypress;
		local keyrelease = keyrelease;
		local gettextbox = user.GetFocusedTextBox;
		local pairs = pairs;
		local catchparts = {"CatchRight","CatchLeft"};
		local function resolveShortest(ball, charac)
			local shortest, chosen = infinite, nil;
			for i, name in pairs(catchparts) do
				local part = FindFirstChild(charac, name);
				local dist = (part and (part.Position - ball.Position).Magnitude) or infinite;
				if (dist < shortest) then
					shortest = dist;
					chosen = part;
				end
			end
			return shortest, chosen;
		end
		local function WaitForChildOfClass(inst, child, maxtime)
			local timer = 0;
			maxtime = maxtime or infinite;
			local found = FindFirstChildOfClass(inst, child);
			while not found and (timer < maxtime) do
				timer = timer + task.wait();
				found = FindFirstChildOfClass(inst, child);
				if found then
					return found;
				end
			end
			return found;
		end
		connect(gui.MenuOpened, function()
			escmenu = true;
		end);
		connect(gui.MenuClosed, function()
			escmenu = false;
		end);
		connect(workspace.ChildAdded, function(ball)
			if ((ball.Name == "Football") and WaitForChildOfClass(ball, "TouchTransmitter", 3)) then
				local charac = lp.Character;
				while (ball.Parent == workspace) and charac do
					local dist, part = resolveShortest(ball, charac);
					if part then
						if (autoclickoffset and (dist <= autoclickoffset) and not (gettextbox(user) or escmenu)) then
							keypress(67);
							wait(0.8);
							keyrelease(67);
						end
						if (dist <= maxdistance) then
							firetouchinterest(part, ball, 1);
							firetouchinterest(part, ball, 0);
						end
					end
					waitfor(stepped);
				end
			end
		end);
	end});
end});
local VisualsButton = Visuals:CreateButton({Name="Ball predictions",Callback=function()
	local Grapher = {};
	Grapher.Marker = Instance.new("Part");
	Grapher.Marker.Anchored = true;
	Grapher.Marker.Transparency = 0.8;
	Grapher.Marker.Color = Color3.fromRGB(255, 0, 255);
	Grapher.Marker.CanCollide = false;
	Grapher.Marker.Name = "Marker";
	Grapher.Params = RaycastParams.new();
	Grapher.Params.IgnoreWater = true;
	Grapher.Params.FilterType = Enum.RaycastFilterType.Whitelist;
	Grapher.CastStep = 3 / 60;
	Grapher.LastSavedPower = 60;
	Grapher.GetCollidables = function(self)
		local Collidables = {};
		for _, BasePart in ipairs(workspace:GetDescendants()) do
			if (BasePart:IsA("BasePart") and (BasePart.CanCollide == true)) then
				table.insert(Collidables, BasePart);
			end
		end
		return Collidables;
	end;
	Grapher.WipeMarkers = function(self)
		for i, v in pairs(workspace:GetChildren()) do
			if (v.Name == "Marker") then
				v:Destroy();
			end
		end
	end;
	Grapher.GetLanding = function(self, origin, velocity, c)
		local Elapsed = 0;
		local LastPos = origin;
		self.Params.FilterDescendantsInstances = self:GetCollidables();
		local Football_Highlight;
		if c then
			Football_Highlight = Instance.new("Highlight", game.CoreGui);
			Football_Highlight.Adornee = c;
			Football_Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop;
			Football_Highlight.Enabled = true;
		end
		while true do
			Elapsed += Grapher.CastStep
			local nPos = (origin + (velocity * Elapsed)) - Vector3.new(0, 0.5 * 28 * (Elapsed ^ 2), 0);
			local Marker = self.Marker:Clone();
			Marker.Parent = workspace;
			Marker.Position = nPos;
			if ((c and Football_Highlight and (c.Parent ~= workspace)) or (c and not c:FindFirstChildOfClass("BodyForce"))) then
				Football_Highlight:Destroy();
				self:WipeMarkers();
				break;
			end
			task.wait();
		end
	end;
	do
		workspace.ChildAdded:Connect(function(child)
			if ((child.Name == "Football") and child:IsA("BasePart")) then
				local tempCon;
				tempCon = child:GetPropertyChangedSignal("Velocity"):Connect(function()
					Grapher:GetLanding(child.Position, child.Velocity, child);
					tempCon:Disconnect();
				end);
			end
		end);
	end
	return Grapher;
end});
local VisualsButton = Visuals:CreateButton({Name="Fps boost",Callback=function()
	local decalsyeeted = true;
	local g = game;
	local w = g.Workspace;
	local l = g.Lighting;
	local t = w.Terrain;
	t.WaterWaveSize = 0;
	t.WaterWaveSpeed = 0;
	t.WaterReflectance = 0;
	t.WaterTransparency = 0;
	l.GlobalShadows = false;
	l.FogEnd = 8999999488;
	l.Brightness = 0;
	settings().Rendering.QualityLevel = "Level01";
	for i, v in pairs(g:GetDescendants()) do
		if (v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart")) then
			v.Material = "Plastic";
			v.Reflectance = 0;
		elseif (v:IsA("Decal") or (v:IsA("Texture") and decalsyeeted)) then
			v.Transparency = 1;
		elseif (v:IsA("ParticleEmitter") or v:IsA("Trail")) then
			v.Lifetime = NumberRange.new(0);
		elseif v:IsA("Explosion") then
			v.BlastPressure = 1;
			v.BlastRadius = 1;
		elseif (v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke")) then
			v.Enabled = false;
		elseif v:IsA("MeshPart") then
			v.Material = "Plastic";
			v.Reflectance = 0;
			v.TextureID = 10385902758728956;
		end
	end
	for i, e in pairs(l:GetChildren()) do
		if (e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect")) then
			e.Enabled = false;
		end
	end
end});
local VisualsButton = Visuals:CreateButton({Name="Skeletons",Callback=function()
	game:GetService("StarterGui"):SetCore("SendNotification", {Title="Made By:",Text="Poog Foog",Icon="",Duration=20});
	local camera = workspace.CurrentCamera;
	local entities = game:GetService("Players");
	local localplayer = entities.LocalPlayer;
	local runservice = game:GetService("RunService");
	local esp_settings = {enabled=true,skel=true,skel_col=Color3.fromRGB(204, 0, 204)};
	local function draw(player, character)
		local skel_head = Drawing.new("Line");
		skel_head.Visible = false;
		skel_head.Thickness = 3;
		skel_head.Color = Color3.new(0, 0, 0);
		local skel_torso = Drawing.new("Line");
		skel_torso.Visible = false;
		skel_torso.Thickness = 3;
		skel_torso.Color = Color3.new(0, 0, 0);
		local skel_leftarm = Drawing.new("Line");
		skel_leftarm.Visible = false;
		skel_leftarm.Thickness = 3;
		skel_leftarm.Color = Color3.new(0, 0, 0);
		local skel_rightarm = Drawing.new("Line");
		skel_rightarm.Visible = false;
		skel_rightarm.Thickness = 3;
		skel_rightarm.Color = Color3.new(0, 0, 0);
		local skel_leftleg = Drawing.new("Line");
		skel_leftleg.Visible = false;
		skel_leftleg.Thickness = 3;
		skel_leftleg.Color = Color3.new(0, 0, 0);
		local skel_rightleg = Drawing.new("Line");
		skel_rightleg.Visible = false;
		skel_rightleg.Thickness = 3;
		skel_rightleg.Color = Color3.new(0, 0, 0);
		local function update()
			local connection;
			connection = runservice.RenderStepped:Connect(function()
				if (workspace:FindFirstChild(character.Name) and character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") and (character:FindFirstChild("Humanoid").Health ~= 0)) then
					local character_rootpart_3d = character.HumanoidRootPart.Position;
					local character_rootpart_2d, rootpart_onscreen = camera:WorldToViewportPoint(character_rootpart_3d);
					if (rootpart_onscreen and (character.Humanoid.RigType == Enum.HumanoidRigType.R6) and esp_settings.enabled) then
						local head_2d = camera:WorldToViewportPoint(character.Head.Position);
						local torso_upper_2d = camera:WorldToViewportPoint(character.Torso.Position + Vector3.new(0, 1, 0));
						local torso_lower_2d = camera:WorldToViewportPoint(character.Torso.Position + Vector3.new(0, -1, 0));
						local leftarm_2d = camera:WorldToViewportPoint(character["Left Arm"].Position + Vector3.new(0, -1, 0));
						local rightarm_2d = camera:WorldToViewportPoint(character["Right Arm"].Position + Vector3.new(0, -1, 0));
						local leftleg_2d = camera:WorldToViewportPoint(character["Left Leg"].Position + Vector3.new(0, -1, 0));
						local rightleg_2d = camera:WorldToViewportPoint(character["Right Leg"].Position + Vector3.new(0, -1, 0));
						skel_head.From = Vector2.new(head_2d.X, head_2d.Y);
						skel_head.To = Vector2.new(torso_upper_2d.X, torso_upper_2d.Y);
						skel_torso.From = Vector2.new(torso_upper_2d.X, torso_upper_2d.Y);
						skel_torso.To = Vector2.new(torso_lower_2d.X, torso_lower_2d.Y);
						skel_leftarm.From = Vector2.new(torso_upper_2d.X, torso_upper_2d.Y);
						skel_leftarm.To = Vector2.new(leftarm_2d.X, leftarm_2d.Y);
						skel_rightarm.From = Vector2.new(torso_upper_2d.X, torso_upper_2d.Y);
						skel_rightarm.To = Vector2.new(rightarm_2d.X, rightarm_2d.Y);
						skel_leftleg.From = Vector2.new(torso_lower_2d.X, torso_lower_2d.Y);
						skel_leftleg.To = Vector2.new(leftleg_2d.X, leftleg_2d.Y);
						skel_rightleg.From = Vector2.new(torso_lower_2d.X, torso_lower_2d.Y);
						skel_rightleg.To = Vector2.new(rightleg_2d.X, rightleg_2d.Y);
						skel_head.Visible = esp_settings.skel;
						skel_torso.Visible = esp_settings.skel;
						skel_leftarm.Visible = esp_settings.skel;
						skel_rightarm.Visible = esp_settings.skel;
						skel_leftleg.Visible = esp_settings.skel;
						skel_rightleg.Visible = esp_settings.skel;
					else
						skel_head.Visible = false;
						skel_torso.Visible = false;
						skel_leftarm.Visible = false;
						skel_rightarm.Visible = false;
						skel_leftleg.Visible = false;
						skel_rightleg.Visible = false;
					end
				else
					if (player == nil) then
						connection:Disconnect();
						connection = nil;
					end
					skel_head.Visible = false;
					skel_torso.Visible = false;
					skel_leftarm.Visible = false;
					skel_rightarm.Visible = false;
					skel_leftleg.Visible = false;
					skel_rightleg.Visible = false;
				end
			end);
		end
		coroutine.wrap(update)();
	end
	local function playeradded(player)
		if player.Character then
			coroutine.wrap(draw)(player, player.Character);
		end
		player.CharacterAdded:Connect(function(character)
			coroutine.wrap(draw)(player, character);
		end);
	end
	for a, b in next, entities:GetPlayers() do
		if (b ~= localplayer) then
			playeradded(b);
		end
	end
	entities.PlayerAdded:Connect(playeradded);
end});
local VisualsToggle = Visuals:CreateToggle({Name="Qb Football Trajectory",CurrentValue=false,Flag="Toggle1",Callback=function(Trajectory)
	local TERRAIN = game.Workspace.Terrain;
	local BEAM = Instance.new("Beam");
	BEAM.Color = ColorSequence.new(Color3.new(1, 0, 1));
	BEAM.Transparency = NumberSequence.new(0);
	BEAM.FaceCamera = true;
	BEAM.Segments = 20;
	BEAM.Width0 = 0.4;
	BEAM.Width1 = 0.4;
	local Trajectory = {};
	Trajectory.__index = Trajectory;
	local function reflect(v, n)
		return (-2 * v:Dot(n) * n) + v;
	end
	local function drawBeamProjectile(g, v0, x0, t)
		local c = 0.5 * 0.5 * 0.5;
		local p3 = (0.5 * g * t * t) + (v0 * t) + x0;
		local p2 = p3 - (((g * t * t) + (v0 * t)) / 3);
		local p1 = ((((c * g * t * t) + (0.5 * v0 * t) + x0) - (c * (x0 + p3))) / (3 * c)) - p2;
		local curve0 = (p1 - x0).Magnitude;
		local curve1 = (p2 - p3).Magnitude;
		local b = (x0 - p3).unit;
		local r1 = (p1 - x0).unit;
		local u1 = r1:Cross(b).unit;
		local r2 = (p2 - p3).unit;
		local u2 = r2:Cross(b).unit;
		b = u1:Cross(r1).unit;
		local cfA = CFrame.fromMatrix(x0, r1, u1, b);
		local cfB = CFrame.fromMatrix(p3, r2, u2, b);
		local A0 = Instance.new("Attachment");
		local A1 = Instance.new("Attachment");
		local Beam = BEAM:Clone();
		A0.CFrame = cfA;
		A0.Parent = TERRAIN;
		A1.CFrame = cfB;
		A1.Parent = TERRAIN;
		Beam.Attachment0 = A0;
		Beam.Attachment1 = A1;
		Beam.CurveSize0 = curve0;
		Beam.CurveSize1 = -curve1;
		Beam.Parent = TERRAIN;
	end
	local Trajectory = {};
	Trajectory.__index = Trajectory;
	local function reflect(v, n)
		return (-2 * v:Dot(n) * n) + v;
	end
	local function drawBeamProjectile(g, v0, x0, t)
		local c = 0.5 * 0.5 * 0.5;
		local p3 = (0.5 * g * t * t) + (v0 * t) + x0;
		local p2 = p3 - (((g * t * t) + (v0 * t)) / 3);
		local p1 = ((((c * g * t * t) + (0.5 * v0 * t) + x0) - (c * (x0 + p3))) / (3 * c)) - p2;
		local curve0 = (p1 - x0).Magnitude;
		local curve1 = (p2 - p3).Magnitude;
		local b = (x0 - p3).unit;
		local r1 = (p1 - x0).unit;
		local u1 = r1:Cross(b).unit;
		local r2 = (p2 - p3).unit;
		local u2 = r2:Cross(b).unit;
		b = u1:Cross(r1).unit;
		local cfA = CFrame.fromMatrix(x0, r1, u1, b);
		local cfB = CFrame.fromMatrix(p3, r2, u2, b);
		local A0 = Instance.new("Attachment");
		local A1 = Instance.new("Attachment");
		local Beam = BEAM:Clone();
		A0.CFrame = cfA;
		A0.Parent = TERRAIN;
		A1.CFrame = cfB;
		A1.Parent = TERRAIN;
		Beam.Attachment0 = A0;
		Beam.Attachment1 = A1;
		Beam.CurveSize0 = curve0;
		Beam.CurveSize1 = -curve1;
		Beam.Parent = TERRAIN;
	end
	Trajectory.new = function(gravity)
		local self = setmetatable({}, Trajectory);
		self.Gravity = gravity;
		self.TimeStep = 0.1;
		self.MaxTime = 3;
		self.MinSpeed = 15;
		self.MaxBounce = 0;
		return self;
	end;
	Trajectory.Velocity = function(self, v0, t)
		return (self.Gravity * t) + v0;
	end;
	Trajectory.Position = function(self, x0, v0, t)
		return (0.5 * self.Gravity * t * t) + (v0 * t) + x0;
	end;
	Trajectory.PlaneQuadraticIntersection = function(self, x0, v0, p, n)
		local a = (0.5 * self.Gravity):Dot(n);
		local b = v0:Dot(n);
		local c = (x0 - p):Dot(n);
		if (a ~= 0) then
			local d = math.sqrt((b * b) - (4 * a * c));
			return (-b - d) / (2 * a);
		else
			return -c / b;
		end
	end;
	Trajectory.CalculateSingle = function(self, x0, v0, ignoreList)
		local t = 0;
		local hit, pos, normal, material;
		repeat
			local p0 = self:Position(x0, v0, t);
			local p1 = self:Position(x0, v0, t + self.TimeStep);
			t = t + self.TimeStep;
			local ray = Ray.new(p0, p1 - p0);
			hit, pos, normal, material = game.Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true);
		until hit or (t >= self.MaxTime) 
		if hit then
			if ((hit.CanCollide == false) and not table.find(ignoreList, hit)) then
				table.insert(ignoreList, hit);
			end
			local t = self:PlaneQuadraticIntersection(x0, v0, pos, normal);
			local x1 = self:Position(x0, v0, t);
			return t, normal, PhysicalProperties.new(material);
		end
	end;
	Trajectory.Cast = function(self, x0, v0, material, ignoreList)
		local bounce = 0;
		local t, x1, normal, pB;
		local speed2 = self.MinSpeed * self.MinSpeed;
		local pA = PhysicalProperties.new(material);
		local path = {};
		while (v0:Dot(v0) >= speed2) and (bounce <= self.MaxBounce) do
			t, normal, pB = self:CalculateSingle(x0, v0, ignoreList);
			if t then
				table.insert(path, {x0,v0,t});
				local elast = ((pA.Elasticity * pA.ElasticityWeight) + (pB.Elasticity * pB.ElasticityWeight)) / (pA.ElasticityWeight + pB.ElasticityWeight);
				local frict = ((pA.Friction * pA.FrictionWeight) + (pB.Friction * pB.FrictionWeight)) / (pA.FrictionWeight + pB.FrictionWeight);
				local dot = 1 - math.abs(v0.Unit:Dot(normal));
				print(dot);
				x0 = self:Position(x0, v0, t);
				v0 = (reflect(self:Velocity(v0, t), normal) * elast) + (v0 * frict * dot);
				bounce = bounce + 1;
			else
				bounce = self.MaxBounce + 1;
			end
		end
		return path;
	end;
	Trajectory.Draw = function(self, path)
		for i = 1, #path do
			local x0, v0, t = unpack(path[i]);
			drawBeamProjectile(self.Gravity, v0, x0, t);
		end
	end;
	local LocalPlayer = game:GetService("Players").LocalPlayer;
	local trajectory = Trajectory.new(Vector3.new(0, -28.5, 0));
	local origin = LocalPlayer.Character:WaitForChild("Head");
	local mouse = LocalPlayer:GetMouse();
	local ignoreList = {game.Workspace.Terrain,LocalPlayer.Character};
	local pause = false;
	game:GetService("RunService").RenderStepped:Connect(function(dt)
		if not pause then
			game.Workspace.Terrain:ClearAllChildren();
			if LocalPlayer.Character:FindFirstChild("Football") then
				local speed = (LocalPlayer.PlayerGui:FindFirstChild("BallGui") and tonumber(LocalPlayer.PlayerGui.BallGui.Frame.Disp.Text)) or 60;
				local dir = (mouse.Hit.p - (origin.CFrame + Vector3.new(0, 1, 0)).p).Unit;
				local x0 = origin.Position + (dir * 2);
				local v0 = dir * speed;
				local path = trajectory:Cast(x0, v0, Enum.Material.Plastic, ignoreList);
				trajectory:Draw(path);
			end
		end
	end);
	game:GetService("UserInputService").InputBegan:Connect(function(input)
		if ((input.UserInputType == Enum.UserInputType.MouseButton1) and not pause) then
			pause = true;
			task.delay(3, function()
				pause = false;
			end);
		end
	end);
end});
local PlayerToggle = Player:CreateToggle({Name="inf jump (banable)",CurrentValue=false,Flag="Toggle1",Callback=function(act, inp, obj)
	wait(1);
	local ver = "2.00";
	local scriptname = "Poog Hub infjump";
	local AirjumpKey = Enum.KeyCode.Space;
	local ca = game:GetService("ContextActionService");
	local zeezy = game:GetService("Players").LocalPlayer;
	local h = 0.0174533;
	local antigrav;
	zeezyAirjump = function(act, inp, obj)
		if (inp == Enum.UserInputState.Begin) then
			repeat
				zeezy.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Seated");
				wait();
				zeezy.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping");
			until true 
		end
	end;
	ca:BindAction("zeezyAirjump", zeezyAirjump, false, AirjumpKey);
	print(scriptname .. " " .. ver .. " loaded successfully");
	print("made by frog#8472");
	local notifSound = Instance.new("Sound", workspace);
	notifSound.PlaybackSpeed = 1.5;
	notifSound.Volume = 0.15;
	notifSound.SoundId = "rbxassetid://170765130";
	notifSound.PlayOnRemove = true;
	notifSound:Destroy();
	game.StarterGui:SetCore("SendNotification", {Title="Poog Hub",Text="Poog foog inf jump loaded ",Icon="rbxassetid://505845268",Duration=800,Button1="Okay"});
end});
local AnimsButton = Anims:CreateButton({Name="Fake Kick",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695538622";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Fake Pass",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695532114";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Fake Dab",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695549792";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Fake Hitstick",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695544849";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Fake knee",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695535660";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Fair Catch",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695548117";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Incomplete Pass",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695542947";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local AnimsButton = Anims:CreateButton({Name="Fake Block",Callback=function()
	for i, v in pairs(game.Players:GetPlayers()) do
		AnimationId = "3695551500";
		local Anim = Instance.new("Animation");
		Anim.AnimationId = "rbxassetid://" .. AnimationId;
		local k = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim);
		k:Play();
		k:AdjustSpeed(1);
	end
end});
local PlayerToggle = Player:CreateToggle({Name="Auto Follow Player (F)",CurrentValue=false,Flag="Toggle1",Callback=function(isFollowing)
	local StarterGui = game:GetService("StarterGui");
	local ScreenGui = Instance.new("ScreenGui", StarterGui);
	local FollowButton = Instance.new("TextButton", ScreenGui);
	FollowButton.Name = "FollowButton";
	FollowButton.Text = "Click to auto-follow nearest player (Press F9 to toggle)";
	local isFollowing = false;
	local followPlayer = nil;
	autoFollow = function()
		local Players = game:GetService("Players");
		local LocalPlayer = Players.LocalPlayer;
		local HumanoidRootPart = LocalPlayer.Character.HumanoidRootPart;
		local MaxDist = 50;
		local MinDist = math.huge;
		local ClosestPlayer = nil;
		for i, player in pairs(Players:GetPlayers()) do
			if (player ~= LocalPlayer) then
				local Character = player.Character;
				if (Character and Character:FindFirstChild("HumanoidRootPart")) then
					local Dist = (Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude;
					if ((Dist < MinDist) and (Dist < MaxDist)) then
						MinDist = Dist;
						ClosestPlayer = player;
					end
				end
			end
		end
		if ClosestPlayer then
			followPlayer = ClosestPlayer;
			repeat
				LocalPlayer.Character.Humanoid:MoveTo(followPlayer.Character.HumanoidRootPart.Position);
				wait();
			until (followPlayer.Character == nil) or (LocalPlayer.Character == nil) or not isFollowing 
		end
		followPlayer = nil;
	end;
	FollowButton.MouseButton1Click:Connect(function()
		if not isFollowing then
			isFollowing = true;
			StarterGui:SetCore("SendNotification", {Title="Auto-follow",Text="Press F to stop auto-following.",Icon="",Duration=math.huge});
			autoFollow();
		end
	end);
	game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessedEvent)
		if (input.KeyCode == Enum.KeyCode.F) then
			isFollowing = not isFollowing;
			if not isFollowing then
				StarterGui:SetCore("SendNotification", {Title="Auto-follow",Text="Auto-following stopped.",Icon="",Duration=5});
				followPlayer = nil;
			else
				StarterGui:SetCore("SendNotification", {Title="Auto-follow (F)",Text="Click on the nearest player to start auto-following them.",Icon="",Duration=math.huge});
				autoFollow();
			end
		end
	end);
end});
